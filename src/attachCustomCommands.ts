import { isObject } from 'lodash';

export interface AttachCustomCommandParams {
  Cypress: any;
  cy: any;
  firebase: any;
}

/**
 * Action for Firestore
 */
export type FirestoreAction = 'get' | 'add' | 'set' | 'update' | 'delete';

/**
 * Data from loaded fixture
 */
export interface FixtureData {
  [k: string]: any;
}

/**
 * Options for building Firestore commands
 */
export interface FirestoreCommandOptions {
  /**
   * Whether or not to include createdAt and createdBy
   */
  withMeta?: boolean;
  /**
   * Extra command line arguments to add to command
   */
  args?: string[];
  /**
   * firebase-tools CI token
   */
  token?: string;
  /**
   * Whether or not to run recursive delete of collections
   * and subcollections
   */
  recursive?: boolean;
  merge?: boolean;
}

/**
 * Action for Real Time Database
 */
export type RTDBAction =
  | 'push'
  | 'remove'
  | 'set'
  | 'update'
  | 'delete'
  | 'get';

/**
 * Options for callRtdb commands
 */
export interface RTDBCommandOptions {
  /**
   * Whether or not to include meta data
   */
  withMeta?: boolean;
  /**
   * Extra arguments
   */
  args?: string[];
  /**
   * CI Token
   */
  token?: string;
  /**
   * Limit to the last <num> results. If true is passed
   * than query is limited to last 1 item.
   */
  limitToLast?: boolean | number;
  /**
   * Limit to the first <num> results. If true is passed
   * than query is limited to last 1 item.
   */
  limitToFirst?: boolean | number;
  /**
   * Select a child key by which to order results
   */
  orderByChild?: string;
  /**
   * Order by key name
   */
  orderByKey?: boolean;
  /**
   * Order by primitive value
   */
  orderByValue?: boolean;
  /**
   * Start results at <val> (based on specified ordering)
   */
  startAt?: any;
  /**
   * End results at <val> (based on specified ordering)
   */
  endAt?: any;
  /**
   * Restrict results to <val> (based on specified ordering)
   */
  equalTo?: any;
  /**
   * Use the database <instance>.firebaseio.com (if omitted, use default database instance)
   */
  instance?: string;
}

// Add custom commands to the existing Cypress interface
declare global {
  /* eslint-disable @typescript-eslint/no-namespace */
  namespace Cypress {
    /* eslint-enable @typescript-eslint/no-namespace */
    interface Chainable {
      /**
       * Login to Firebase auth using a custom token. Multiple methods for loading custom
       * tokens are supported including:
       * 1. TEST_UID environment variable
       * 2. By Passing a UID as an argument
       * 3. FIREBASE_AUTH_JWT environment variable (generated by createTestEnvFile)
       * @see https://github.com/prescottprue/cypress-firebase#cylogin
       * @param uid - UID of user to login as
       * @param customClaims - Custom claims to attach to the custom token
       * @example <caption>Env Based Login (TEST_UID or FIREBASE_AUTH_JWT)</caption>
       * cy.login()
       * @example <caption>Passed UID</caption>
       * cy.login('123SOMEUID')
       */
      login: (uid?: string, customClaims?: any) => Chainable;

      /**
       * Log current user out of Firebase Auth
       * @see https://github.com/prescottprue/cypress-firebase#cylogout
       * @example
       * cy.logout()
       */
      logout: () => Chainable;

      /**
       * Call Real Time Database path with some specified action. Authentication is through
       * `FIREBASE_TOKEN` (CI token) since firebase-tools is used under the hood, allowing
       * for admin privileges.
       * @param action - The action type to call with (set, push, update, remove)
       * @param actionPath - Path within RTDB that action should be applied
       * @param opts - Options
       * @param opts.args - Command line args to be passed
       * @see https://github.com/prescottprue/cypress-firebase#cycallrtdb
       * @example <caption>Set Data</caption>
       * const fakeProject = { some: 'data' }
       * cy.callRtdb('set', 'projects/ABC123', fakeProject)
       * @example <caption>Set Data With Meta Data</caption>
       * const fakeProject = { some: 'data' }
       * // Adds createdAt and createdBy (current user's uid) on data
       * cy.callRtdb('set', 'projects/ABC123', fakeProject, { withMeta: true })
       */
      callRtdb: (
        action: RTDBAction,
        actionPath: string,
        fixtureDataOrPath?: FixtureData | string,
        opts?: RTDBCommandOptions,
      ) => Chainable;

      /**
       * Call Firestore instance with some specified action. Authentication is through
       * serviceAccount.json since it is at the base
       * level. If using delete, auth is through `FIREBASE_TOKEN` since
       * firebase-tools is used (instead of firebaseExtra).
       * @param action - The action type to call with (set, push, update, remove)
       * @param actionPath - Path within RTDB that action should be applied
       * @param opts - Options
       * @param opts.args - Command line args to be passed
       * @see https://github.com/prescottprue/cypress-firebase#cycallfirestore
       * @example <caption>Set Data</caption>
       * const project = { some: 'data' }
       * cy.callFirestore('set', 'project/test-project', project)
       * @example <caption>Add New Document</caption>
       * const project = { some: 'data' }
       * cy.callFirestore('add', 'projects', project)
       * @example <caption>Basic Get</caption>
       * cy.callFirestore('get', 'projects/test-project').then((project) => {
       *   cy.log('Project:', project)
       * })
       * @example <caption>Recursive Delete</caption>
       * const opts = { recursive: true }
       * cy.callFirestore('delete', 'project/test-project', opts)
       * @example <caption>Manually Loading Fixture</caption>
       * cy.fixture('fakeProject.json').then((project) => {
       *   cy.callFirestore('add', 'projects', project)
       * })
       * @example <caption>Fixture Path</caption>
       * cy.callFirestore('set', 'project/test-project', 'fakeProject.json')
       * @example <caption>Other Args</caption>
       * const opts = { args: ['-r'] }
       * cy.callFirestore('delete', 'project/test-project', opts)
       */
      callFirestore: (
        action: FirestoreAction,
        actionPath: string,
        fixtureDataOrPath?: FixtureData | string,
        opts?: FirestoreCommandOptions,
      ) => Chainable;
    }
  }
}

/**
 * @param firebase - firebase instance
 * @param customToken - Custom token to use for login
 * @returns Promise which resolves with the user auth object
 */
function loginWithCustomToken(
  firebase: any,
  customToken: string,
): Promise<any> {
  return new Promise((resolve, reject): any => {
    firebase.auth().onAuthStateChanged((auth: any) => {
      if (auth) {
        resolve(auth);
      }
    });
    firebase
      .auth()
      .signInWithCustomToken(customToken)
      .catch(reject);
  });
}

/**
 * Attach custom commands including cy.login, cy.logout, cy.callRtdb,
 * @param commandParams - List of params to provide scope during
 * custom command attachment
 */
export default function attachCustomCommands(
  commandParams: AttachCustomCommandParams,
): void {
  const { Cypress, cy, firebase } = commandParams;

  /**
   * Login to Firebase auth using either a passed uid or the FIREBASE_AUTH_JWT
   * environment variable which is generated using firebase-admin authenticated
   * with serviceAccount during call to createTestEnvFile.
   * @name cy.login
   */
  Cypress.Commands.add('login', (uid?: string, customClaims?: any): any => {
    const userUid = uid || Cypress.env('TEST_UID');
    // Handle UID which is passed in
    if (userUid) {
      // Resolve with current user if they already exist
      if (
        firebase.auth().currentUser &&
        userUid === firebase.auth().currentUser.uid
      ) {
        cy.log('Authed user already exists, login complete.');
        return undefined;
      }
      cy.log('Creating custom token for login...');

      // Generate a custom token using createCustomToken task (if tasks are enabled) then login
      if (Cypress.env('useCypressFirebaseTasks')) {
        cy.log('Calling create customToken task', userUid);
        return cy
          .task('createCustomToken', { uid: userUid, customClaims })
          .then((customToken: string) =>
            loginWithCustomToken(firebase, customToken),
          );
      }
    }

    // Resolve with currentUser if they exist
    if (firebase.auth().currentUser) {
      cy.log('Authed user already exists, login complete.');
      // Undefined is returned to prevent Cypress error:
      // "Cypress detected that you invoked one or more cy commands in a custom command but returned a different value."
      return undefined;
    }

    // Throw if JWT not within environment (passed uid case handled above)
    if (!Cypress.env('FIREBASE_AUTH_JWT')) {
      /** Log in using token * */
      const errMsg =
        'uid must be passed to cy.login or FIREBASE_AUTH_JWT must be set to cypress environment in order to login';
      cy.log(errMsg);
      throw new Error(errMsg);
    }

    // Otherwise, login with Token from environment
    return loginWithCustomToken(firebase, Cypress.env('FIREBASE_AUTH_JWT'));
  });

  /**
   * Log out of Firebase instance
   * @name cy.logout
   * @see https://github.com/prescottprue/cypress-firebase#cylogout
   * @example
   * cy.logout()
   */
  Cypress.Commands.add(
    'logout',
    (): Promise<any> => {
      return new Promise((resolve: Function, reject: Function): any => {
        firebase.auth().onAuthStateChanged((auth: any) => {
          if (!auth) {
            resolve();
          }
        });
        firebase
          .auth()
          .signOut()
          .catch(reject);
      });
    },
  );

  /**
   * Call Real Time Database path with some specified action. Authentication is through
   * FIREBASE_TOKEN since firebase-tools is used (instead of firebaseExtra).
   * @param action - The action type to call with (set, push, update, remove)
   * @param actionPath - Path within RTDB that action should be applied
   * @param opts - Options
   * @param opts.args - Command line args to be passed
   * @name cy.callRtdb
   */
  Cypress.Commands.add(
    'callRtdb',
    (
      action: RTDBAction,
      actionPath: string,
      data?: any,
      opts?: RTDBCommandOptions,
    ) => {
      // If data is an object, create a copy to original object is not modified
      const dataToWrite = isObject(data) ? { ...data } : data;

      // Add metadata to dataToWrite if specified by options
      if (isObject(data) && opts && opts.withMeta) {
        dataToWrite.createdBy = Cypress.env('TEST_UID');
        dataToWrite.createdAt = firebase.database.ServerValue.TIMESTAMP;
      }

      const taskSettings: any = {
        action,
        path: actionPath,
      };
      // Add data only for write actions
      if (['set', 'update', 'push'].includes(action)) {
        taskSettings.data = dataToWrite;
      }
      // Use third argument as options for get action
      if (action === 'get') {
        taskSettings.options = data;
      } else if (opts) {
        // Attach options if they exist
        taskSettings.options = opts;
      }
      return cy.task('callRtdb', taskSettings);
    },
  );

  /**
   * Call Firestore instance with some specified action. Authentication is through serviceAccount.json since it is at the base
   * level. If using delete, auth is through `FIREBASE_TOKEN` since firebase-tools is used (instead of firebaseExtra).
   * @param action - The action type to call with (set, push, update, remove)
   * @param actionPath - Path within RTDB that action should be applied
   * @param opts - Options
   * @param opts.args - Command line args to be passed
   * @name cy.callFirestore
   */
  Cypress.Commands.add(
    'callFirestore',
    (
      action: FirestoreAction,
      actionPath: string,
      data: any,
      opts: FirestoreCommandOptions,
    ): void => {
      // If data is an object, create a copy to original object is not modified
      const dataToWrite = isObject(data) ? { ...data } : data;

      // Add metadata to dataToWrite if specified by options
      if (isObject(data) && opts?.withMeta) {
        if (!dataToWrite.createdBy) {
          dataToWrite.createdBy = Cypress.env('TEST_UID');
        }
        if (!dataToWrite.createdAt) {
          dataToWrite.createdAt = new Date().toISOString();
        }
      }

      const taskSettings: any = {
        action,
        path: actionPath,
      };
      // Add data only for write actions
      if (['set', 'update', 'add'].includes(action)) {
        taskSettings.data = dataToWrite;
      }
      // Use third argument as options for get action
      if (action === 'get') {
        taskSettings.options = data;
      } else if (opts) {
        // Attach options if they exist
        taskSettings.options = opts;
      }
      return cy.task('callFirestore', taskSettings);
    },
  );
}
